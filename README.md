# Snaky
Это моя версия игры в змейку с использованием модуля Pygame, включающая пять уровней и различные виды бонусных фруктов. Графика рисуется путем импорта изображений и размещения их на соответствующих прямоугольниках с использованием Pygame.
## Установка
Для установки модуля Pygame выполните следующие шаги:
Скачайте установочный пакет Python 3 с официального веб-сайта и установите его, если его еще нет.
Запустите следующую команду в терминале для установки библиотеки Pygame:
```
pip3 install pygame
```
## Запуск приложения
Скачайте исходный код из репозитория и запустите файл так же, как и любой другой файл сценария Python (.py).

Чтобы запустить игру, выполните:
```
python3 main.py
```
## 
Для инициализации змеи мы создали класс Snake, который содержит следующие методы: 

1. *Конструктор* (из цвета).

2. *draw_snake* - отвечает за отрисовку нашей змеи.

3. *update_head_graphics* - определяет положение головы змеи.

4. *update_tail_graphics* - аналогичен предыдущему методу, но для хвоста.

5. *move_snake* - перемещает нашу змею в текущем направлении, в случае столкновения добавляет еще одну координату к телу змеи.

6. *add_block* - проверяет, нужно ли добавить блок к змее.

7. *play_crunch_sound* - используется для воспроизведения звука при столкновении.

## Фрукты
Класс Fruit довольно тривиальный, у нас есть три вида фруктов, которые мы рисуем на случайных координатах каждый раз.

1. *Конструктор*.

2. *draw_apple* - рисует обычное яблоко, которое приносит 1 очко.

3. *draw_orange* - рисует апельсин, который приносит 5 очков.

4. *draw_watermelon* - рисует арбуз, который указывает на победу.

5. *randomize* - размещает фрукт в случайной позиции, используя модуль random.

## Трава
Этот класс содержит карты различных уровней.

1. *Конструктор* - содержит границы различных уровней (списки с координатами стен).

2. *draw_grass* - отвечает за отрисовку наших карт на экране.
## Main(Логика)
В этом классе мы просто определяем, что должна делать наша игра в каждой итерации игрового цикла.

1. *Конструктор* - здесь мы инициализируем элементы нашей игры (т.е. Snake, Fruit, Grass).

2. *update* - используется для обновления элементов игры, таких как движение змеи и проверка на проигрыш.

3. *draw_elements* - этот метод используется для отрисовки всех наших элементов (травы, змеи и фруктов).

4. *check_collision* - этот метод проверяет, съела ли наша змея фрукт, и случайным образом размещает фрукт в случае неправильной позиции (граница, тело змеи), также увеличивает скорость змеи при столкновении.

5. *check_next_level* - проверяет, перешли ли мы на следующий уровень.

6. *pass_to_lvlv1(2, 3, 4, 5)* - в случае перехода на следующий уровень эти методы сбрасывают скорость змеи и саму змею, также выводят сообщение о переходе на следующий уровень.

7. *check_fail* - здесь мы проверяем, закончена ли наша игра.

8. *update_record* - этот метод обновляет таблицу лучших результатов.

9. *game_overa_output* - в этом методе мы рисуем экран "Game Over" и проигрываем соответствующие звуки, также в случае установки нового рекорда отправляем сообщение о том, что вы установили новый рекорд. Здесь мы также сбрасываем текущий счет, уровень и змею, и обновляем таблицу рекордов.

10. *draw_top_score* - этот метод используется для вывода лидеров счета.

11. *draw_score* - используется для указания текущего счета в правом нижнем углу во время игры.

12. *game_won* - эта функция отвечает за вывод "You Won" и воспроизведение соответствующих звуков в случае завершения игры. Здесь мы также сбрасываем некоторые значения и нашу змею.

13. *pause* - этот метод используется для приостановки игры, и мы можем выводить любой текст в этом окне приостановки, передавая аргументы, которые мы хотим вывести. Для продолжения игры нужно нажать клавишу "c", для выхода - клавишу "q".

14. *check_game_won* - проверяет, выиграли ли мы игру.
 
## Другие детали

1. Наша змея состоит из блоков, поэтому мы определяем наш экран как сетку, cell_size - размер одной ячейки в пикселях, cell_number - длина одной стороны нашего квадрата (экрана).

2. Мы инициализируем Pygame и определяем наш экран, также устанавливаем начальную скорость змеи snake_speed = 6.

3. Затем мы инициализируем экземпляр clock для отслеживания кадров в секунду.

4. Мы используем Pygame.mixer для воспроизведения звуков, и мы используем pygame.mixer.pre_init() для воспроизведения звуков без задержки.

5. Мы отслеживаем время между нажатиями клавиш, чтобы избежать множественных нажатий одновременно.

## Игровой цикл
Здесь мы в основном работаем с событиями Pygame для обработки команд пользователей. Есть несколько условий, которые учитывают различные случаи. Здесь мы также обновляем направление на каждой итерации, затем обновляем и рисуем элементы main_game.



